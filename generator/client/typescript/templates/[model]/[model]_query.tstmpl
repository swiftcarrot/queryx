// Code generated by queryx, DO NOT EDIT.

import type { QXClient, Clause } from "../queryx";
import { SelectStatement, newInsert, newDelete, adapterScan } from "../queryx";
import type { {{ $.model.Name }}ChangeInput } from "./{{ $.model.Name | snake }}_change";
import { {{ $.model.Name }}Change } from "./{{ $.model.Name | snake }}_change";
import { {{ $.model.Name }} } from "./{{ $.model.Name | snake }}";
{{- range $b := $.model.BelongsTo }}
import type { {{ pascal $b.ModelName }} } from "../{{ snake $b.ModelName }}";
{{- end }}
{{- range $h := $.model.HasMany }}
import type { {{ pascal $h.ModelName }} } from "../{{ snake $h.ModelName }}";
{{- end }}
{{- range $h := $.model.HasOne }}
import type { {{ pascal $h.ModelName }} } from "../{{ snake $h.ModelName }}";
{{- end }}

{{- define "primary_key_params" }}
  {{- range $i, $c := $.Columns -}}
    {{ if $i }}, {{ end }}{{ $c.Name | camel }}: {{ tsType $c.Type }}
  {{- end -}}
{{- end }}

{{- define "primary_key_where" }}
  {{- if gt (len $.PrimaryKey.Columns) 1 -}}
    this.client.and(
    {{- range $i, $c := index $.PrimaryKey.Columns -}}
      {{ if $i }}, {{ end }}this.client.{{ $.Name | camel }}{{ $c.Name | pascal }}.eq({{ $c.Name | camel }})
    {{- end -}})
  {{- else -}}
    {{- $c := index $.PrimaryKey.Columns 0 -}}
    this.client.{{ .Name | camel }}{{ $c.Name | pascal }}.eq({{ $c.Name | camel }})
  {{- end -}}
{{- end }}

export class {{ $.model.Name }}Query {
  private client: QXClient;
  private selectStatement: SelectStatement;
  private preload: { [key: string]: boolean };

  constructor(client: QXClient) {
    this.client = client;
    this.selectStatement = new SelectStatement();
    this.selectStatement.select("{{ $.model.TableName }}.*").from("{{ $.model.TableName }}");
    this.preload = {};
  }

  async create(input?: {{ $.model.Name }}ChangeInput) {
    let change = new {{ $.model.Name }}Change(input);
    {{- if $.model.Timestamps }}
    let now = new Date().toISOString();
    if (change.createdAt === undefined) {
      change.setCreatedAt(now);
    }
    if (change.updatedAt === undefined) {
      change.setUpdatedAt(now);
    }
    {{- end }}

    let [columns, values] = change.changes();
    {{- if eq $.client.Adapter "mysql" }}
    let [query, args] = newInsert()
      .into("{{ $.model.TableName }}")
      .columns(...columns)
      .values(...values)
      .toSQL();
    let res = await this.client.adapter._exec(query, ...args);
    {{- if $.model.DefaultPrimaryKey }}
    let filter = this.client.{{ $.model.Name | camel }}ID.eq(res.insertId);
    let record = await this.where(filter).first();
    {{- else }}
    let record = new {{ $.model.Name }}(this.client);
    record.applyChange(input);
    {{- end }}
    {{- else }}
    let [query, args] = newInsert()
      .into("{{ $.model.TableName }}")
      .columns(...columns)
      .values(...values)
      .returning("*")
      .toSQL();

    let row = await this.client.queryOne(query, ...args);
    let record = new {{ $.model.Name }}(this.client);

    {{- range $c := $.model.Columns }}
    record.{{ $c.Name | camel }} = adapterScan("{{ $c.Type }}", row.{{ $c.Name }});
    {{- end }}
    {{- end }}

    return record;
  }

  async insertAll(inputs: {{ $.model.Name }}ChangeInput[]) {
    if (inputs.length == 0) {
      throw new Error("insert all with empty inputs");
    }
    const s = newInsert().into("{{ $.model.TableName }}");
    for (const [index, input] of inputs.entries()) {
      const change = new {{ $.model.Name }}Change(input);
      {{- if $.model.Timestamps }}
      const now = new Date().toISOString();
      if (input.createdAt === undefined) {
        change.setCreatedAt(now);
      }
      if (input.updatedAt === undefined) {
        change.setUpdatedAt(now);
      }
      {{- end }}
      const [columns, values] = change.changes();
      if (index === 0) {
        s.columns(...columns);
      }
      s.values(...values);
    }
    let [query, args] = s.toSQL();
    return await this.client.exec(query, ...args);
  }

  {{- if $.model.PrimaryKey }}

  async delete({{ template "primary_key_params" $.model.PrimaryKey }}) {
    let filter = this.client.{{ $.model.Name | camel }}ID.eq(id);
    let [query, args] = newDelete("{{ $.model.TableName }}").where(filter).toSQL();
    return await this.client.exec(query, ...args);
  }

  async find({{ template "primary_key_params" $.model.PrimaryKey }}) {
    let record = await this.where({{ template "primary_key_where" $.model }}).first();
    if (!record) {
      return Promise.reject("Record not found");
    }
    return record;
  }
  {{- end }}

  findBy(where: Clause) {
    return this.where(where).first();
  }

  findBySQL(query: string, ...args: any[]) {
    return this.query<{{ $.model.Name }}>(query, ...args);
  }

  where(...clauses: Clause[]) {
    this.selectStatement.where(...clauses);
    return this;
  }

  select(...selection: string[]) {
    this.selectStatement.select(...selection);
  }

  limit(limit: number) {
    this.selectStatement.limit(limit);
    return this;
  }

  offset(offset: string) {
    this.selectStatement.offset(offset);
    return this;
  }

  group(group: string) {
    this.selectStatement.group(group);
    return this;
  }

  having(having: string) {
    this.selectStatement.having(having);
    return this;
  }

  joins(joins: string) {
    this.selectStatement.join(joins);
    return this;
  }

  order(order: string) {
    this.selectStatement.order(order);
    return this;
  }

  {{- range $b := $.model.BelongsTo }}

  preload{{ pascal $b.Name }}() {
    this.preload["{{ $b.Name}}"] = true;
    return this;
  }

  private async _preload{{ pascal $b.Name }}(records: {{ $b.ModelName }}[]) {
    let ids = records.map((record) => record.{{ $b.ForeignKey | camel }});
    let rows1 = await this.client
      .query{{ $b.ModelName }}()
      .where(this.client.{{ camel $b.ModelName }}ID.in(ids))
      .all();

    let m: { [key: number]: {{ $b.ModelName }} } = {};
    for (let row of rows1) {
      m[Number(row.id)] = row
    }

    for (let record of records) {
      record.{{ camel $b.Name }} = m[Number(record.{{ $b.ForeignKey | camel }})];
    }
  }
  {{- end }}

  {{- range $h := $.model.HasMany }}

  preload{{ pascal $h.Name }}() {
    this.preload["{{ $h.Name }}"] = true;
    return this;
  }

  private async _preload{{ pascal $h.Name }}(records: {{ $.model.Name }}[]) {
    let ids = records.map((record) => record.id);

    {{- if $h.Through }}
    {{- $m := $h.Through | singular | pascal }}
    let rows1 = await this.client
      .query{{ $m }}()
      .where(this.client.{{ camel $m }}{{ $.model.Name }}ID.in(ids))
      .all();

    let m1: { [key: number]: {{ $m }}[] } = {};
    for (let row of rows1) {
      if (!m1[Number(row.{{ camel $.model.Name }}ID)]) {
        m1[Number(row.{{ camel $.model.Name }}ID)] = [];
      }
      m1[Number(row.{{ camel $.model.Name }}ID)].push(row);
    }

    for (let record of records) {
      if (m1[Number(record.id)] && m1[Number(record.id)].length) {
        record.{{ camel $h.Through }} = m1[Number(record.id)];
      } else {
        record.{{ camel $h.Through }} = [];
      }
    }

    let ids1 = rows1.map(row => row.{{ $h.ModelName | camel }}ID);
    let rows2 = await this.client
      .query{{ $h.ModelName }}()
      .where(this.client.{{ $h.ModelName | camel }}ID.in(ids1))
      .all();
    let m2: { [key: number]: {{ $h.ModelName }} } = {};
    for (let row of rows2) {
      m2[Number(row.id)] = row;
    }
    for (let row of rows1) {
      row.{{ $h.ModelName | camel }} = m2[Number(row.{{ $h.ModelName | camel }}ID)];
    }
    let m3: { [key: number]: {{ $h.ModelName }}[] } = {};
    for (let row of rows1) {
      if (!m3[Number(row.{{ camel $.model.Name }}ID)]) {
        m3[Number(row.{{ camel $.model.Name }}ID)] = [];
      }
      m3[Number(row.{{ camel $.model.Name }}ID)].push(row.{{ camel $h.ModelName }});
    }
    for (let record of records) {
      if (m3[Number(record.id)] && m3[Number(record.id)].length) {
        record.{{ camel $h.Name }} = m3[Number(record.id)];
      } else {
        record.{{ camel $h.Name }} = [];
      }
    }
    {{- else }}
    let rows1 = await this.client
      .query{{ $h.ModelName }}()
      .where(this.client.{{ camel $h.ModelName }}{{ $.model.Name }}ID.in(ids))
      .all();

    let m: { [key: number]: {{ $h.ModelName }} } = {};
    for (let r of rows1) {
      if (!m[Number(r.{{ camel $.model.Name }}ID)]) {
        m[Number(r.{{ camel $.model.Name }}ID)] = [];
      }
      m[Number(r.{{ camel $.model.Name }}ID)].push(r);
    }

    for (let record of records) {
      if (m[Number(record.id)] && m[Number(record.id)].length) {
        record.{{ camel $h.Name }} = m[Number(record.id)];
      } else {
        record.{{ camel $h.Name }} = [];
      }
    }
    {{- end }}
  }
  {{- end }}

  {{- range $h := $.model.HasOne }}

  preload{{ pascal $h.Name }}() {
    this.preload["{{ $h.Name }}"] = true;
    return this;
  }

  private async _preload{{ pascal $h.Name }}(records: {{ $h.ModelName }}[]) {
    let ids = records.map((record) => record.id);
    let rows1 = await this.client
      .query{{ $h.ModelName }}()
      .where(this.client.{{ camel $h.ModelName }}{{ $.model.Name }}ID.in(ids))
      .all();

    let m: { [key: number]: {{ $h.ModelName }} } = {};
    for (let r of rows1) {
      m[Number(r.{{ camel $.model.Name }}ID)] = r
    }

    for (let record of records) {
      record.{{ camel $h.Name }} = m[Number(record.id)];
    }
  }
  {{- end }}

  async all() {
    let [query, args] = this.selectStatement.toSQL();
    let rows = await this.client.query(query, ...args);
    let records: {{ $.model.Name }}[] = [];
    for (let row of rows) {
      let record = new {{ $.model.Name }}(this.client);
      {{- range $c := $.model.Columns }}
      record.{{ $c.Name | camel }} = adapterScan("{{ $c.Type }}", row.{{ $c.Name }});
      {{- end }}
      records.push(record);
    }

    {{- range $b := $.model.BelongsTo }}
    if (this.preload["{{ $b.Name }}"]) {
      await this._preload{{ pascal $b.Name }}(records);
    }
    {{- end }}
    {{- range $h := $.model.HasMany }}
    if (this.preload["{{ $h.Name }}"]) {
      await this._preload{{ pascal $h.Name }}(records);
    }
    {{- end }}
    {{- range $h := $.model.HasOne }}
    if (this.preload["{{ $h.Name }}"]) {
      await this._preload{{ pascal $h.Name }}(records);
    }
    {{- end }}

    return records;
  }

  async first() {
    this.limit(1);
    let records = await this.all();
    return records[0] || null;
  }

  async count() {
    this.selectStatement.select("COUNT(*) as count");
    let [query, args] = this.selectStatement.toSQL();
    let res = await this.client.queryOne(query, ...args);
    return res.count;
  }

  async exists() {
    this.selectStatement.select("1 AS one").limit(1);
    let [query, args] = this.selectStatement.toSQL();
    let res = await this.client.queryOne<{ one: number }>(query, ...args);
    return res?.one == 1;
  }

  async updateAll(input: {{ $.model.Name }}ChangeInput) {
    let change = new {{ $.model.Name }}Change(input);
    {{- if $.model.Timestamps }}
    let now = new Date().toISOString();
    if (change.updatedAt === undefined) {
      change.setUpdatedAt(now)
    }
    {{- end }}
    let [columns, values] = change.changes();
    let [query, args] = this.selectStatement
      .update()
      .columns(...columns)
      .values(...values)
      .toSQL();
    let res = await this.client.exec(query, ...args);
    return res;
  }

  async deleteAll() {
    let [query, args] = this.selectStatement.delete().toSQL();
    let res = await this.client.exec(query, ...args);
    return res;
  }
}
