// Code generated by queryx, DO NOT EDIT.

import type { QXClient } from "../queryx";
import type { {{ $.model.Name }}ChangeInput } from "./{{ $.model.Name | snake}}_change";
{{- range $b := $.model.BelongsTo }}
import type { {{ $b.ModelName }} } from "../{{ $b.ModelName | snake }}";
{{- end }}
{{- range $h := $.model.HasMany }}
import type { {{ $h.ModelName }} } from "../{{ $h.ModelName | snake }}";
{{- end }}
{{- range $h := $.model.HasOne }}
import type { {{ $h.ModelName }} } from "../{{ $h.ModelName | snake }}";
{{- end }}

export interface {{ $.model.Name }}Row {}

export class {{ $.model.Name }} {
  {{- range $c := $.model.Columns }}
  public {{ $c.Name | camel }}: {{ tsType $c.Type }}{{ if $c.Null }} | null{{ end }} = null;
  {{- end }}
  {{- range $b := $.model.BelongsTo }}
  public {{ $b.Name | camel }}: {{ $b.ModelName }} | null;
  {{- end }}
  {{- range $h := $.model.HasMany }}
  public {{ $h.Name | camel }}: {{ $h.ModelName }}[] | null;
  {{- end }}
  {{- range $h := $.model.HasOne }}
  public {{ $h.Name | camel }}: {{ $h.ModelName }} | null;
  {{- end }}
  private _client: QXClient;

  constructor(client: QXClient) {
    this._client = client;
    {{- range $b := $.model.BelongsTo }}
    this.{{ $b.Name | camel }} = null;
    {{- end }}
    {{- range $h := $.model.HasMany }}
    this.{{ $h.Name | camel }} = null;
    {{- end }}
    {{- range $h := $.model.HasOne }}
    this.{{ $h.Name | camel }} = null;
    {{- end }}
  }

  applyChange(input: {{ $.model.Name }}ChangeInput) {
    {{- range $c := $.model.Columns }}
    if (input.{{ $c.Name | camel }} !== undefined) {
      {{- if eq $c.Type "date" }}
      this.{{ $c.Name | camel }} = new Date(input.{{ $c.Name | camel }});
      {{- else if eq $c.Type "datetime" }}
      this.{{ $c.Name | camel }} = new Date(input.{{ $c.Name | camel }});
      {{- else }}
      this.{{ $c.Name | camel }} = input.{{ $c.Name | camel }};
      {{- end }}
    }
    {{- end }}
  }

  {{- if $.model.PrimaryKey }}
  async update(input: {{ $.model.Name }}ChangeInput) {
    {{- if $.model.Timestamps }}
    let now = new Date().toISOString();
    if (input.updatedAt === undefined) {
      input.updatedAt = now;
    }
    {{- end }}
    let filter = this._client.{{ $.model.Name | camel }}ID.eq(this.id);
    await this._client.query{{ $.model.Name }}().where(filter).updateAll(input);
    this.applyChange(input);
  }

  async delete() {
    let filter = this._client.{{ $.model.Name | camel }}ID.eq(this.id);
    return await this._client.query{{ $.model.Name }}().where(filter).deleteAll();
  }
  {{- end }}

  {{- range $h := $.model.HasMany }}

  query{{ $h.Name | pascal }}()  {
    {{- if $h.Through }}
    return this._client.query{{ $h.ModelName }}()
      .joins("INNER JOIN {{ $h.Through }} ON {{ $h.Through }}.{{ $h.ModelName | snake }}_id = {{ $h.Name }}.id")
      .where(this._client.{{ $h.Through | singular | pascal | camel }}{{ $h.ForeignKey | pascal }}.eq(this.id));
    {{- else }}
    return this._client.query{{ $h.ModelName }}().where(this._client.{{ $h.ModelName | camel }}{{ $h.ForeignKey | pascal }}.eq(this.id));
    {{- end }}
  }
  {{- end }}

  toString() {
    let str = "({{ $.model.Name }}";
    {{- range $i, $c := $.model.Columns }}
    {{- if ne $i 0 }}
    str += ","
    {{- end }}
    {{- if eq $c.Type "string" }}
    str += " {{ $c.Name | camel }}: " + '"' + this.{{ $c.Name | camel }} + '"';
    {{- else }}
    str += " {{ $c.Name | camel }}: " + this.{{ $c.Name | camel }};
    {{- end }}
    {{- end }}
    str += ")";
    return str;
  }

  toJSON() {
    return {
    {{- range $c := $.model.Columns }}
      {{ $c.Name | camel }}: this.{{ $c.Name | camel }},
    {{- end }}
    {{- range $b := $.model.BelongsTo }}
      {{ $b.Name | camel }}: this.{{ $b.Name | camel }},
    {{- end }}
    {{- range $h := $.model.HasMany }}
      {{ $h.Name | camel }}: this.{{ $h.Name | camel }},
    {{- end }}
    {{- range $h := $.model.HasOne }}
      {{ $h.Name | camel }}: this.{{ $h.Name | camel }},
    {{- end }}
    };
  }
}
