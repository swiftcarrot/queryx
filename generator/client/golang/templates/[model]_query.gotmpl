// Code generated by queryx, DO NOT EDIT.

package {{ $.packageName }}

import (
	"database/sql"
	"errors"
	"fmt"

	"{{ $.goModPath }}/{{ $.packageName }}/queryx"
)

{{- define "primary_key_params" }}
	{{- range $i, $c := $.Columns -}}
		{{ if $i }}, {{ end }}{{ $c.Name | camel | goKeywordFix }} {{ goModelType $c.Type $c.Null }}
	{{- end -}}
{{- end }}

{{- define "primary_key_where" }}
	{{- if gt (len $.PrimaryKey.Columns) 1 -}}
		q.schema.And(
		{{- range $i, $c := index $.PrimaryKey.Columns -}}
			{{ if $i }}, {{ end }}q.schema.{{ $.Name }}{{ $c.Name | pascal }}.EQ({{ $c.Name | camel | goKeywordFix }})
		{{- end -}})
	{{- else -}}
		{{- $c := index $.PrimaryKey.Columns 0 -}}
		q.schema.{{ .Name }}{{ $c.Name | pascal }}.EQ({{ $c.Name | camel | goKeywordFix }})
	{{- end -}}
{{- end }}

{{- define "mysql_primary_key_custom" }}
	{{- if gt (len $.PrimaryKey.Columns) 0 -}}
		q.schema.And(
		{{- range $i, $c := index $.PrimaryKey.Columns -}}
			{{ if $i }}, {{ end }}q.schema.{{ $.Name }}{{ $c.Name | pascal }}.EQ(change.{{ $c.Name | pascal | goKeywordFix }}.Val)
		{{- end -}})
	{{- end -}}
{{- end }}

{{- define "mysql_primary_key_default" }}
	{{- $c := index $.PrimaryKey.Columns 0 -}}
	q.schema.{{ .Name }}{{ $c.Name | pascal }}.EQ({{ $c.Name | camel | goKeywordFix }})
{{- end }}

type {{ $.model.Name }}Query struct {
	adapter *queryx.Adapter
	schema *queryx.Schema
	queries Queries
	selectStatement *queryx.SelectStatement
	preload map[string]bool
	err error
}

func New{{ $.model.Name }}Query(adapter *queryx.Adapter, schema *queryx.Schema, queries Queries) *{{ $.model.Name }}Query {
	s := queryx.NewSelect().Select("{{ $.model.TableName }}.*").From("{{ $.model.TableName }}")
	return &{{ $.model.Name }}Query{
		adapter: adapter,
		schema: schema,
		queries: queries,
		selectStatement: s,
		preload: make(map[string]bool),
	}
}

func (q *{{ $.model.Name }}Query) Create(change *queryx.{{ $.model.Name }}Change) (*{{ $.model.Name }}, error) {
	if q.err != nil {
 		return nil, q.err
 	}

 	record := &{{ $.model.Name }}{
		schema: q.schema,
		queries: q.queries,
	}
	{{- if $.model.Timestamps }}
	now := queryx.Now("2006-01-02 15:04:05.000")
	if !change.CreatedAt.Set {
		change.SetCreatedAt(now)
	}
	if !change.UpdatedAt.Set {
		change.SetUpdatedAt(now)
	}
	{{- end }}

 	{{- if or (eq .client.Adapter "postgresql") (eq $.client.Adapter "sqlite") }}
	columns, values := change.Changes()
	query, args := queryx.NewInsert().
		Into("{{ $.model.TableName }}").
		Columns(columns...).
		Values(values...).
		Returning("*").ToSQL()
	err := q.adapter.QueryOne(query, args...).Scan(record)
	if err != nil {
		return nil, err
	}
	{{- else if eq $.client.Adapter "mysql"}}
	columns, values := change.Changes()
	query, args := queryx.NewInsert().Into("{{ $.model.TableName }}").Columns(columns...).Values(values...).ToSQL()
	{{- if $.model.DefaultPrimaryKey }}
	result, err := q.adapter.ExecInternal(query, args...)
	if err != nil {
		return nil, err
	}
	id, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("insert fail:%+v", err)
	}
	return q.Where({{ template "mysql_primary_key_default" $.model }}).First()
	{{- else if $.model.PrimaryKey }}
	result, err := q.adapter.ExecInternal(query, args...)
	if err != nil {
		return nil, err
	}
	affected, err := result.RowsAffected()
	if affected == 0 || err != nil {
		return nil, fmt.Errorf("insert fail:%+v, or affected rows equal to 0",err)
	}
	return q.Where({{ template "mysql_primary_key_custom" $.model }}).First()
	{{- else }}
	_, err := q.adapter.ExecInternal(query, args...)
	if err != nil {
		return nil, err
	}
	record.applyChange(change)
	{{- end }}
	{{- end }}

	return record, nil
}

func (q *{{.model.Name}}Query) InsertAll(changes []*queryx.{{.model.Name}}Change) (int64, error){
	if q.err != nil {
		return 0, q.err
	}

	if len(changes) == 0 {
		return 0, ErrInsertAllEmptyChanges
	}

	{{- if eq $.model.Timestamps true }}
	now := queryx.Now("2006-01-02 15:04:05.000")
	for _, change := range changes {
		if !change.CreatedAt.Set {
			change.SetCreatedAt(now)
		}
		if !change.UpdatedAt.Set {
			change.SetUpdatedAt(now)
		}
	}
	{{- end }}

	s := queryx.NewInsert().Into("{{ $.model.TableName }}")
	for i, change := range changes {
		columns, values := change.Changes()
		if i == 0 {
			s.Columns(columns...)
		}
		s.Values(values...)
	}

	query, args := s.ToSQL()
	return q.adapter.Exec(query, args...)
}

{{- if $.model.PrimaryKey }}

func (q *{{ $.model.Name }}Query) Delete({{ template "primary_key_params" $.model.PrimaryKey }}) (int64, error) {
	query, args := queryx.NewDelete().From("{{.model.TableName}}").Where({{ template "primary_key_where" $.model }}).ToSQL()
	result, err := q.adapter.Exec(query, args...)
	if err != nil {
		return 0, err
	}
	return result, err
}

func (q *{{.model.Name}}Query) Find({{ template "primary_key_params" $.model.PrimaryKey }}) (*{{.model.Name}}, error) {
	res, err := q.Where({{ template "primary_key_where" $.model }}).First()
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, sql.ErrNoRows
	}
	res.schema = q.schema
	res.queries = q.queries
	return res, err
}
{{- end }}

func (q *{{.model.Name}}Query) FindBy(where *queryx.Clause) (*{{.model.Name}}, error) {
	return q.Where(where).First()
}

func (q *{{.model.Name}}Query) FindBySQL(query string, args ...interface{}) ([]*{{.model.Name}}, error) {
	var {{firstWordLowerCamel .model.Name}}List []{{.model.Name}}
	{{firstWordLowerCamel .model.Name}}s := make([]*{{.model.Name}}, 0)
	err := q.adapter.Query(query, args...).Scan(&{{firstWordLowerCamel .model.Name}}List)
	if err != nil {
	return nil, err
	}
	for i := 0; i < len({{firstWordLowerCamel .model.Name}}List); i++ {
		{{firstWordLowerCamel .model.Name}}s = append({{firstWordLowerCamel .model.Name}}s, &{{firstWordLowerCamel .model.Name}}List[i])
	}
	return {{firstWordLowerCamel .model.Name}}s, nil
}

func (q *{{.model.Name}}Query) Where(clauses ...*queryx.Clause) *{{.model.Name}}Query {
	q.selectStatement.Where(clauses...)
	return q
}

func (q *{{.model.Name}}Query) Select(selection ...string) *{{.model.Name}}Query {
	q.selectStatement.Select(selection...)
	return q
}

func (q *{{.model.Name}}Query) Limit(limit int) *{{.model.Name}}Query {
	q.selectStatement.Limit(limit)
	return q
}

func (q *{{.model.Name}}Query) Offset(offset int) *{{.model.Name}}Query {
	q.selectStatement.Offset(offset)
	return q
}

func (q *{{.model.Name}}Query) Group(group string) *{{.model.Name}}Query {
	q.selectStatement.GroupBy(group)
	return q
}

func (q *{{.model.Name}}Query) Having(having string) *{{.model.Name}}Query {
	q.selectStatement.Having(having)
	return q
}

func (q *{{.model.Name}}Query) Joins(joins string) *{{.model.Name}}Query {
	q.selectStatement.Join(joins)
	return q
}

func (q *{{.model.Name}}Query) Order(order ...string) *{{.model.Name}}Query {
	q.selectStatement.Order(order...)
	return q
}

{{- range $b := $.model.BelongsTo }}

func (q *{{ $.model.Name }}Query) Preload{{ pascal $b.Name }}() *{{ $.model.Name }}Query {
	q.preload["{{ $b.Name }}"] = true
	return q
}

func (q *{{ $.model.Name }}Query) preload{{ pascal $b.Name }}(rows []*{{ $.model.Name }}) error {
	ids := []int64{}
	for _, r := range rows {
		{{- if $b.Null }}
		if r.{{ $b.ForeignKey | pascal }}.Valid {
			ids = append(ids, r.{{ $b.ForeignKey | pascal }}.Val)
		}
		{{- else }}
		ids = append(ids, r.{{ $b.ForeignKey | pascal }})
		{{- end }}
	}
	rows1, err := q.queries.Query{{ $b.ModelName }}().Where(q.schema.{{ $b.ModelName }}ID.In(ids)).All()
	if err != nil {
		return err
	}

	m := make(map[int64]*{{ $b.ModelName }})
	for _, r := range rows1 {
		m[r.ID] = r
	}
	for _, r := range rows {
		{{- if $b.Null }}
		if r.{{ $b.ForeignKey | pascal }}.Valid {
			r.{{ $b.Name | pascal }} = m[r.{{ $b.ForeignKey | pascal }}.Val]
		}
		{{- else }}
		r.{{ $b.Name | pascal }} = m[r.{{ $b.ForeignKey | pascal }}]
		{{- end }}
	}

	return nil
}
{{- end }}

{{- range $h := $.model.HasMany }}

func (q *{{ $.model.Name }}Query) Preload{{ pascal $h.Name }}() *{{ $.model.Name }}Query {
	q.preload["{{ $h.Name }}"] = true
	return q
}

func (q *{{ $.model.Name }}Query) preload{{ pascal $h.Name }}(rows []*{{ $.model.Name }}) error {
	ids := []int64{}
	for _, r := range rows {
		ids = append(ids, r.ID)
	}

	{{- if $h.Through }}
	{{- $m := $h.Through | singular | pascal }}
	rows1, err := q.queries.Query{{ $m }}().Where(q.schema.{{ $m }}{{ $.model.Name }}ID.In(ids)).All()
	if err != nil {
		return err
	}
	m1 := make(map[int64][]*{{ $m }})
	for _, r := range rows1 {
		m1[r.{{ $.model.Name }}ID.Val] = append(m1[r.{{ $.model.Name }}ID.Val], r)
	}
	for _, r := range rows {
		if m1[r.ID] != nil {
			r.{{ $h.Through | pascal }} = m1[r.ID]
		} else {
			r.{{ $h.Through | pascal }} = make([]*{{ $m }}, 0)
		}
	}

	ids1 := []int64{}
	for _, r := range rows1 {
		ids1 = append(ids1, r.{{ $h.ModelName }}ID.Val)
	}
	rows2, err := q.queries.Query{{ $h.ModelName }}().Where(q.schema.{{ $h.ModelName }}ID.In(ids1)).All()
	if err != nil {
		return err
	}
	m2 := make(map[int64]*{{ $h.ModelName}})
	for _, r := range rows2 {
		m2[r.ID] = r
	}
	for _, r := range rows1 {
		r.{{ $h.ModelName}} = m2[r.{{ $h.ModelName}}ID.Val]
	}

	m3 := make(map[int64][]*{{ $h.ModelName }})
	for _, r := range rows1 {
		m3[r.{{ $.model.Name }}ID.Val] = append(m3[r.{{ $.model.Name }}ID.Val], r.{{ $h.ModelName }})
	}
	for _, r := range rows {
		if m3[r.ID] != nil {
			r.{{ $h.Name | pascal }} = m3[r.ID]
		} else {
			r.{{ $h.Name | pascal }} = make([]*{{ $h.ModelName }},0)
		}
	}
	{{- else }}
	rows1, err := q.queries.Query{{ $h.ModelName }}().Where(q.schema.{{ $h.ModelName }}{{ $.model.Name }}ID.In(ids)).All()
	if err != nil {
		return err
	}

	m := make(map[int64][]*{{ $h.ModelName }})
	for _, r := range rows1 {
		m[r.{{ $.model.Name }}ID.Val] = append(m[r.{{ $.model.Name }}ID.Val], r)
	}
	for _, r := range rows {
		if m[r.ID] != nil {
			r.{{ $h.Name | pascal }} = m[r.ID]
		} else {
			r.{{ $h.Name | pascal }} = make([]*{{ $h.ModelName }}, 0)
		}
	}
	{{- end }}

	return nil
}
{{- end }}

{{- range $h := $.model.HasOne }}

func (q *{{ $.model.Name }}Query) Preload{{ pascal $h.Name }}() *{{ $.model.Name }}Query {
	q.preload["{{ $h.Name }}"] = true
	return q
}

func (q *{{ $.model.Name }}Query) preload{{ pascal $h.Name }}(rows []*{{ $.model.Name }}) error {
	ids := []int64{}
	for _, r := range rows {
		ids = append(ids, r.ID)
	}
	rows1, err := q.queries.Query{{ $h.ModelName }}().Where(q.schema.{{ $h.ModelName }}{{ $h.ForeignKey | pascal }}.In(ids)).All()
	if err != nil {
		return err
	}

	m := make(map[int64]*{{ $h.ModelName }})
	for _, r := range rows1 {
		{{- if $h.BelongsTo.Null }}
		m[r.{{ $h.ForeignKey | pascal }}.Val] = r
		{{- else }}
		m[r.{{ $h.ForeignKey | pascal }}] = r
		{{- end }}
	}
	for _, r := range rows {
		r.{{ $h.ModelName }} = m[r.ID]
	}

	return nil
}
{{- end }}

func (q *{{.model.Name}}Query) All() ([]*{{.model.Name}}, error) {
	if q.err != nil{
		return nil, q.err
	}
	var rows []{{ $.model.Name }}
	{{- $var1 := $.model.Name | camel | plural }}
	{{ $var1 }} := make([]*{{ $.model.Name }}, 0)
	query, args := q.selectStatement.ToSQL()
	err := q.adapter.Query(query, args...).Scan(&rows)
	if err != nil {
		return nil, err
	}

	if len(rows) == 0 {
		return {{ $var1 }}, nil
	}

	for i := range rows {
		rows[i].schema = q.schema
		rows[i].queries = q.queries
		{{ $var1 }} = append({{ $var1 }}, &rows[i])
	}

	{{- range $b := $.model.BelongsTo }}
	if q.preload["{{ $b.Name }}"] {
		if err := q.preload{{ $b.Name | pascal }}({{ $var1 }}); err != nil {
			return nil, err
		}
	}
	{{- end }}

	{{- range $h := $.model.HasMany }}
	if q.preload["{{ $h.Name }}"] {
		if err := q.preload{{ $h.Name | pascal }}({{ $var1 }}); err != nil {
			return nil, err
		}
	}
	{{- end }}

	{{- range $h := $.model.HasOne }}
	if q.preload["{{ $h.Name }}"] {
		if err := q.preload{{ $h.Name | pascal }}({{ $var1 }}); err != nil {
			return nil, err
		}
	}
	{{- end }}

	return {{ $var1 }}, nil
}

func (q *{{ $.model.Name }}Query) First() (*{{.model.Name}}, error) {
	q.Limit(1)
	results, err := q.All()
	if err != nil {
		return nil, err
	}
	if len(results) > 0 {
		return results[0], nil
	}

	return nil, nil
}

func (q *{{ $.model.Name }}Query) Count() (int64, error) {
	var res struct {
		Count int64 `db:"count"`
	}
	q.selectStatement.Select("count(*)")
	query, args := q.selectStatement.ToSQL()
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
	return 0, err
	}

	return res.Count, nil
}

func (q *{{ $.model.Name }}Query) Avg(v string) (float64, error) {
	var res struct {
		Avg sql.NullFloat64 `db:"avg"`
	}
	q.selectStatement.Select(fmt.Sprintf("avg(%+v)", v))
	query, args := q.selectStatement.ToSQL()
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		return 0, err
	}

	return res.Avg.Float64, nil
}

func (q *{{ $.model.Name }}Query) Sum(v string) (float64, error) {
	var res struct {
		Sum sql.NullFloat64 `db:"sum"`
	}
	q.selectStatement.Select(fmt.Sprintf("sum(%+v)", v))
	query, args := q.selectStatement.ToSQL()
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		return 0, err
	}

	return res.Sum.Float64, nil
}

func (q *{{ $.model.Name }}Query) Max(v string) (float64, error) {
	var res struct {
		Max sql.NullFloat64 `db:"max"`
	}
	q.selectStatement.Select(fmt.Sprintf("max(%+v)",v))
	query, args := q.selectStatement.ToSQL()
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		return 0, err
	}

	return res.Max.Float64, nil
}

func (q *{{ $.model.Name }}Query) Min(v string) (float64, error) {
	var res struct {
		Min sql.NullFloat64 `db:"min"`
	}
	q.selectStatement.Select(fmt.Sprintf("min(%+v)",v))
	query, args := q.selectStatement.ToSQL()
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		return 0, err
	}

	return res.Min.Float64, nil
}

func (q *{{ $.model.Name }}Query) Exists() (bool, error) {
	q.selectStatement.Select("1 AS one").Limit(1)
	// select 1 as one from users limit 1
	query, args := q.selectStatement.ToSQL()
	var res struct {
		One int64 `db:"one"`
	}
	if err := q.adapter.QueryOne(query, args...).Scan(&res); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return false, nil
		}
		return false, err
		}

		return res.One == 1, nil
}

func (q *{{ $.model.Name }}Query) UpdateAll(change *queryx.{{ $.model.Name }}Change) (int64, error) {
	if q.err != nil {
		return 0, q.err
	}

	{{- if $.model.Timestamps }}
	now := queryx.Now("2006-01-02 15:04:05.000")
	if !change.UpdatedAt.Set {
		change.SetUpdatedAt(now)
	}
	{{- end }}
 	columns, values := change.Changes()
	query, args := q.selectStatement.Update().Columns(columns...).Values(values...).ToSQL()
	result, err := q.adapter.Exec(query, args...)
	if err != nil {
		return 0, err
	}
	return result, err
}

func (q *{{ $.model.Name }}Query) DeleteAll() (int64, error) {
	query, args := q.selectStatement.Delete().ToSQL()
	result, err := q.adapter.Exec(query, args...)
	if err != nil {
		return 0, err
	}
	return result, err
}
