// Code generated by queryx, DO NOT EDIT.

package queryx

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"strings"
)

type StringArray struct {
	Val   []string
	Valid bool
	Set   bool
}

func NewStringArray(v []string) StringArray {
	return StringArray{Val: v, Valid: true, Set: true}
}

func NewNullableStringArray(v *[]string) StringArray {
	if v != nil {
		return NewStringArray(*v)
	}
	return StringArray{Set: true}
}

// Scan implements the Scanner interface.
func (s *StringArray) Scan(value interface{}) error {
	if value == nil {
		s.Val, s.Valid = nil, false
		return nil
	}

	switch v := value.(type) {
	case []byte:
		s.Valid = true
		return s.parseArray(string(v))
	case string:
		s.Valid = true
		return s.parseArray(v)
	case []string:
		s.Val, s.Valid = v, true
		return nil
	default:
		return fmt.Errorf("unsupported Scan type for StringArray: %T", value)
	}
}

// parseArray parses a PostgreSQL array string into a Go string slice
func (s *StringArray) parseArray(str string) error {
	if str == "{}" {
		s.Val = []string{}
		return nil
	}

	// Simple parsing for basic arrays
	// This is a simplified implementation and might not handle all edge cases
	str = strings.TrimPrefix(str, "{")
	str = strings.TrimSuffix(str, "}")

	// Split by comma, but respect quotes
	parts := []string{}
	inQuote := false
	current := ""

	for _, r := range str {
		switch r {
		case '"':
			inQuote = !inQuote
			current += string(r)
		case ',':
			if inQuote {
				current += string(r)
			} else {
				parts = append(parts, current)
				current = ""
			}
		default:
			current += string(r)
		}
	}

	if current != "" {
		parts = append(parts, current)
	}

	// Strip quotes and unescape
	result := make([]string, len(parts))
	for i, p := range parts {
		p = strings.TrimSpace(p)
		if strings.HasPrefix(p, "\"") && strings.HasSuffix(p, "\"") {
			// Unquote the string
			p = p[1 : len(p)-1]
			// Unescape escaped quotes
			p = strings.ReplaceAll(p, "\"\"", "\"")
		}
		result[i] = p
	}

	s.Val = result
	return nil
}

// Value implements the driver Valuer interface.
func (s StringArray) Value() (driver.Value, error) {
	if !s.Valid {
		return nil, nil
	}

	if s.Val == nil {
		return "{}", nil
	}

	// Format slice as PostgreSQL array
	escaped := make([]string, len(s.Val))
	for i, v := range s.Val {
		// Escape special characters and quote
		v = strings.ReplaceAll(v, "\"", "\"\"")
		escaped[i] = fmt.Sprintf("\"%s\"", v)
	}

	return fmt.Sprintf("{%s}", strings.Join(escaped, ",")), nil
}

// MarshalJSON implements the json.Marshaler interface.
func (s StringArray) MarshalJSON() ([]byte, error) {
	if !s.Valid {
		return json.Marshal(nil)
	}
	return json.Marshal(s.Val)
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (s *StringArray) UnmarshalJSON(data []byte) error {
	s.Set = true
	if string(data) == "null" {
		return nil
	}
	s.Valid = true
	if err := json.Unmarshal(data, &s.Val); err != nil {
		return err
	}
	return nil
}

// String implements the stringer interface.
func (s StringArray) String() string {
	if !s.Valid {
		return "null"
	}
	bytes, _ := json.Marshal(s.Val)
	return string(bytes)
}
