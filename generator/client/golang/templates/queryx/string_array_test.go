// Code generated by queryx, DO NOT EDIT.

package queryx

import (
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestNewStringArray(t *testing.T) {
	// Test with a non-empty slice
	s1 := NewStringArray([]string{"a", "b", "c"})
	require.Equal(t, []string{"a", "b", "c"}, s1.Val)
	require.True(t, s1.Valid)
	require.True(t, s1.Set)

	// Test with an empty slice
	s2 := NewStringArray([]string{})
	require.Equal(t, []string{}, s2.Val)
	require.True(t, s2.Valid)
	require.True(t, s2.Set)

	// Test with nullable, non-nil value
	v := []string{"x", "y"}
	s3 := NewNullableStringArray(&v)
	require.Equal(t, []string{"x", "y"}, s3.Val)
	require.True(t, s3.Valid)
	require.True(t, s3.Set)

	// Test with nullable, nil value
	s4 := NewNullableStringArray(nil)
	require.False(t, s4.Valid)
	require.True(t, s4.Set)
}

func TestStringArrayJSON(t *testing.T) {
	type Foo struct {
		X StringArray `json:"x"`
		Y StringArray `json:"y"`
	}

	x := NewStringArray([]string{"a", "b", "c"})
	y := NewNullableStringArray(nil)
	s := `{"x":["a","b","c"],"y":null}`

	f1 := Foo{X: x, Y: y}
	b, err := json.Marshal(f1)
	require.NoError(t, err)
	require.Equal(t, s, string(b))

	var f2 Foo
	err = json.Unmarshal([]byte(s), &f2)
	require.NoError(t, err)
	require.Equal(t, x, f2.X)
	require.Equal(t, y, f2.Y)
}

func TestStringArrayScan(t *testing.T) {
	// Test scanning from nil
	var s1 StringArray
	err := s1.Scan(nil)
	require.NoError(t, err)
	require.False(t, s1.Valid)
	require.Nil(t, s1.Val)

	// Test scanning from PostgreSQL array string format
	var s2 StringArray
	err = s2.Scan(`{"a","b","c"}`)
	require.NoError(t, err)
	require.True(t, s2.Valid)
	require.Equal(t, []string{"a", "b", "c"}, s2.Val)

	// Test scanning from byte slice
	var s3 StringArray
	err = s3.Scan([]byte(`{"x","y"}`))
	require.NoError(t, err)
	require.True(t, s3.Valid)
	require.Equal(t, []string{"x", "y"}, s3.Val)

	// Test scanning from string slice
	var s4 StringArray
	err = s4.Scan([]string{"p", "q"})
	require.NoError(t, err)
	require.True(t, s4.Valid)
	require.Equal(t, []string{"p", "q"}, s4.Val)

	// Test scanning from empty array
	var s5 StringArray
	err = s5.Scan(`{}`)
	require.NoError(t, err)
	require.True(t, s5.Valid)
	require.Equal(t, []string{}, s5.Val)

	// Test scanning from unsupported type
	var s6 StringArray
	err = s6.Scan(123)
	require.Error(t, err)
}

func TestStringArrayValue(t *testing.T) {
	// Test with valid array
	s1 := NewStringArray([]string{"a", "b", "c"})
	v1, err := s1.Value()
	require.NoError(t, err)
	require.Equal(t, `{"a","b","c"}`, v1)

	// Test with invalid array
	s2 := StringArray{Valid: false}
	v2, err := s2.Value()
	require.NoError(t, err)
	require.Nil(t, v2)

	// Test with nil slice but valid flag
	s3 := StringArray{Valid: true, Val: nil}
	v3, err := s3.Value()
	require.NoError(t, err)
	require.Equal(t, "{}", v3)

	// Test with values that need escaping
	s4 := NewStringArray([]string{`a"quote`})
	v4, err := s4.Value()
	require.NoError(t, err)
	require.Equal(t, `{"a""quote"}`, v4)
}

func TestStringArrayString(t *testing.T) {
	// Test with valid array
	s1 := NewStringArray([]string{"a", "b", "c"})
	require.Equal(t, `["a","b","c"]`, s1.String())

	// Test with invalid array
	s2 := StringArray{Valid: false}
	require.Equal(t, "null", s2.String())
}
