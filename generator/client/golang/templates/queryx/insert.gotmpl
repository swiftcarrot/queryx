// Code generated by queryx, DO NOT EDIT.

package queryx

import (
	"fmt"
	"strings"
)

type InsertStatement struct {
	into       string
	columns    []string
	values     [][]interface{}
	returning  []string
	onConflict string
	isDefault  []bool
}

func NewInsert() *InsertStatement {
	return &InsertStatement{}
}

func (s *InsertStatement) Into(into string) *InsertStatement {
	s.into = into
	return s
}

func (s *InsertStatement) Columns(columns ...string) *InsertStatement {
	s.columns = columns
	return s
}

func (s *InsertStatement) Values(values ...interface{}) *InsertStatement {
	if len(values) > 0 {
		s.values = append(s.values, values)
	}
	return s
}

{{- if or (eq $.client.Adapter "postgresql") (eq $.client.Adapter "sqlite") }}
func (s *InsertStatement) Returning(returning ...string) *InsertStatement {
	s.returning = returning
	return s
}
{{- end }}

func (s *InsertStatement) OnConflict(onConflict string) *InsertStatement {
	s.onConflict = onConflict
	return s
}

func (s *InsertStatement) IsDefault(isDefault ...bool) *InsertStatement {
	if len(isDefault) > 0 {
		s.isDefault = append(s.isDefault, isDefault...)
	}
	return s
}

func (s *InsertStatement) ToSQL() (string, []interface{}) {
	sql := fmt.Sprintf("INSERT INTO %s", s.into)

	if len(s.columns) > 0 {
		{{- if eq $.client.Adapter "mysql" }}
		sql = fmt.Sprintf("%s(`%s`)", sql, strings.Join(s.columns, "`, `"))
		{{- else }}
		sql = fmt.Sprintf("%s(%s)", sql, strings.Join(s.columns, ", "))
		{{- end }}
	} else {
		{{- if eq $.client.Adapter "mysql" }}
		sql = fmt.Sprintf("%s VALUES ()", sql)
		{{- else }}
		sql = fmt.Sprintf("%s DEFAULT VALUES", sql)
		{{- end }}
	}
	values := []string{}
    ss := []string{}
    for i, _ := range s.isDefault {
    	if s.isDefault[i] {
    		ss = append(ss, "DEFAULT")
    	} else {
    		ss = append(ss, "?")
    	}
    	if len(ss)%len(s.columns) == 0 {
    		values = append(values, fmt.Sprintf("(%s)", strings.Join(ss, ", ")))
    		ss = []string{}
    	}
    }
	if len(values) > 0 {
		sql = fmt.Sprintf("%s VALUES %s", sql, strings.Join(values, ", "))
	}

	if len(s.returning) > 0 {
		sql = fmt.Sprintf("%s RETURNING %s", sql, strings.Join(s.returning, ", "))
	}

	if s.onConflict != "" {
		sql = fmt.Sprintf("%s %s", sql, s.onConflict)
	}

	args := []interface{}{}
	for _, v := range s.values {
		args = append(args, v...)
	}

	return sql, args
}
